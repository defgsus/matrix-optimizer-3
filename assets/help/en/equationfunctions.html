{{ abs(x)
Returns the absolute value of <i>x</i> - that is the result is always positive.
}}

{{ sign(x)
Returns +1.0 if <i>x</i> is positive, -1.0 if <i>x</i> is negative and 0.0 if <i>x</i> is zero.
}}

{{ floor(x)
Returns <i>x</i> without the fractional part, e.g. 2.7 becomes 2.0
<br/><b>floor(x)</b>:<br/><img src="_equ#0#8#0#8#floor(x)"/>
}}

{{ ceil(x)
Returns <i>x</i> without the fractional part plus one, e.g 2.3 becomes 3.0
<br/><b>ceil(x)</b>:<br/><img src="_equ#0#8#0#8#ceil(x)"/>
}}

{{ round(x)
Returns <i>x</i> rounded to the nearest integer, e.g. 2.4 becomes 2.0 and 2.5 becomes 3.0
<br/><b>round(x)</b>:<br/><img src="_equ#0#8#0#8#round(x)"/>
}}

{{ frac(x)
Returns the fractional part (the digits right of the point).
}}

{{ clamp(x, min, max)
Limits the value of <i>x</i> to the range [<i>min</i>,<i>max</i>].
}}

{{ min(x, y)
Returns the smallest of the values <i>x</i> and <i>y</i>
}}

{{ max(x, y)
Returns the largest of the values <i>x</i> and <i>y</i>
}}


{{ even(x)
Returns 1 if <i>x</i> is an even number, 0 otherwise.
}}

{{ odd(x)
Returns 1 if <i>x</i> is an odd number, 0 otherwise.
}}

{{ mix(x, y, t)
Linearily interpolates between values <i>x</i> and <i>y</i> by the factor <i>t</i> of range [0,1]. <i>t</i> = 0 returns <i>x</i>, <i>t</i> = 1 returns <i>y</i>, <i>t</i> = 0.5 returns the average. This function is sometimes also called <b>lerp</b> (for linear interpolation).
<br/><b>mix( <a href="#square">square</a>(x), <a href="#tri">tri</a>(x), <a href="#clamp">clamp</a>(x,0,1) )</b>:<br/><img src="_equ#-4#4#-1#1#mix(square(x),tri(x),clamp(x,0,1))"/>
}}

{{ quant(x, q)
Quantizes <i>x</i> to the interval <i>q</i>
<br/><b>quant(x,0.3)</b>:<br/><img src="_equ#0#2#0#2#quant(x,0.3)"/>
}}

{{ mod(x, m)
Returns <i>x</i> modulo <i>m</i>, that is, <i>x</i> will always be in the range of [0,<i>m</i>).
}}

{{ smod(x, m)
Returns <i>x</i> modulo <i>b</i> if <i>x</i> is positive and <i>m</i> - (-<i>x</i> modulo <i>m</i>) if <i>x</i> is negative, that is, <i>x</i> will always be in the range of [0,<i>m</i>). This function should be used for creating continious functions from a value that might be negative as well.
}}

{{ sin(x)
Returns the sinus of <i>x</i>. <i>x</i> is in radians, so a full interval is [0,<i>TWO_PI</i>].
<br/><b>sin(x)</b>:<br/><img src="_equ#0#6.283#-1#1#sin(x)"/>
}}

{{ sinh(x)
Returns the sinus hyperbolicus of <i>x</i>.
<br/><b>sinh(x)</b>:<br/><img src="_equ#-3.1416#3.1416#-12#12#sinh(x)"/>
}}

{{ asin(x)
Returns the arcus sinus of <i>x</i>. This translates an angle back to it's sine part. <i>x</i> is in the range of [-1,1], the result is in radians.
<br/><b>asin(x)</b>:<br/><img src="_equ#-1#1#-1.58#1.58#asin(x)"/>
}}

{{ asinh(x)
Returns the inverse sinus hyperbolicus of <i>x</i>.
<br/><b>asinh(x)</b>:<br/><img src="_equ#-30#30#-4#4#asinh(x)"/>
}}

{{ cos(x)
Returns the cosinus of <i>x</i>. <i>x</i> is in radians, so a full interval is [0,<i>TWO_PI</i>].
<br/><b>cos(x)</b>:<br/><img src="_equ#0#6.283#-1#1#cos(x)"/>
}}

{{ cosh(x)
Returns the cosinus hyperbolicus of <i>x</i>.
<br/><b>cosh(x)</b>:<br/><img src="_equ#-3.1416#3.1416#0#12#cosh(x)"/>
}}

{{ acos(x)
Returns the arcus cosinus of <i>x</i>. This translates an angle back to it's cosine part. <i>x</i> is in the range of [-1,1], the result is in radians [0,PI].
<br/><b>acos(x)</b>:<br/><img src="_equ#-1#1#0#3.1416#acos(x)"/>
}}

{{ acosh(x)
Returns the inverse cosinus hyperbolicus of <i>x</i>.
<br/><b>acosh(x)</b>:<br/><img src="_equ#1#30#0#4#acosh(x)"/>
}}


{{ tan(x)
Returns the tangens of <i>x</i>. <i>x</i> is in radians, so a full interval is [0,<i>TWO_PI</i>].
<br/><b>tan(x)</b>:<br/><img src="_equ#0#6.283#-4#4#tan(x)"/>
}}

{{ tanh(x)
Returns the tangens hyperbolicus of <i>x</i>.
<br/>This function has the nice property of fitting all input values into the range [-1,1], so it can be usefull as a saturation function.
<br/><b>tanh(x)</b>:<br/><img src="_equ#-4#4#-1#1#tanh(x)"/>
}}

{{ atan(x)
Returns the arcus tangens of <i>x</i>. <i>x</i> is in the range of [-1,1], the result is in radians.
<br/><b>atan(x)</b>:<br/><img src="_equ#-10#10#-1.58#1.58#atan(x)"/>
}}

{{ atan(a, b)
Returns the arcus tangens of <i>a</i>/<i>b</i>. The result is in radians ranging from -<i>PI</i> to +<i>PI</i>.
<br/>This function is useful to translate a vector position into an angle. For any point x,y (except 0,0) <b>atan(y,x)</b> returns the angle in radians between the positive x-axis and the point.
}}

{{ atanh(x)
Returns the inverse tangens hyperbolicus of <i>x</i>.
<br/><b>atanh(x)</b>:<br/><img src="_equ#-1#1#-3#3#atanh(x)"/>
}}

{{ sinc(x)
Calculates <b>sin(<i>x</i>) / <i>x</i></b>, which gives a sine wave with a maximum at zero, fading out in negative and positive directions.
<br/><b>sinc(x)</b>:<br/><img src="_equ#-20#20#-1#1#sinc(x)"/>
}}

{{ exp(x)
The exponential function. This raises <i>E</i> (Euler's constant) to the power of <i>x</i>
}}

{{ log(x)
The natural logarithm function returns the exponent to which <i>E</i> (Euler's constant) must be raised to receive <i>x</i>
}}

{{ log2(x)
The base 2 logarithm function returns the exponent to which 2 must be raised to receive <i>x</i>
}}

{{ log10(x)
The base 10 logarithm function returns the exponent to which 10 must be raised to receive <i>x</i>
}}

{{ pow(x, exp)
Raises <i>x</i> to the power of <i>exp</i>
}}

{{ sqrt(x)
Returns the square root (or second root) of <i>x</i>
}}

{{ root(x, r)
Returns the <i>r</i>th root of <i>x</i>
}}


{{ logistic(x)
A function borrowed mainly from statistics. The result equals <b>1 / (1 + exp(-<i>x</i>))</b> and is always in the range of [0,1].
<br/><b>logistic(x)</b>:<br/><img src="_equ#-5#5#0#1#logistic(x)"/>
}}

{{ erf(x)
The Gauss error function. See <a href="http://en.wikipedia.org/wiki/Error_function">Error function</a> on wikipedia.
<br/><b>erf(x)</b>:<br/><img src="_equ#-2#2#-1#1#erf(x)"/>
}}

{{ erfc(x)
The completmentary error function. See <a href="http://en.wikipedia.org/wiki/Error_function">Error function</a> on wikipedia.
<br/><b>erfc(x)</b>:<br/><img src="_equ#-2#2#0#2#erfc(x)"/>
}}

{{ gauss(x, dev)
The Gaussian function returns a "bell curve" around zero. <i>dev</i> is the standard deviation.
<br/><b>gauss(x, 1)</b>:<br/><img src="_equ#-4#4#0#1#gauss(x,1)"/>
}}

{{ gauss(x, dev, center)
The Gaussian function returns a "bell curve" around <i>center</i>. <i>dev</i> is the standard deviation.
<br/><b>gauss(x, 1, 2)</b>:<br/><img src="_equ#-4#6#0#1#gauss(x,1,2)"/>
}}

{{ cauchy(x, s)
Returns the probability density of the Cauchy distribution around zero. <i>s</i> is the scale parameter.
<br/><b>cauchy(x, 1)</b>:<br/><img src="_equ#-4#4#0#1#cauchy(x,1)"/>
}}

{{ cauchy(x, s, center)
Returns the probability density of the Cauchy distribution around <i>center</i>. <i>s</i> is the scale parameter.
<br/><b>cauchy(x, 1, 2)</b>:<br/><img src="_equ#-4#6#0#1#cauchy(x,1,2)"/>
}}


{{ smstep(edge1, edge2, x)
Smoothly fades between 0 and 1 for the value <i>x</i> between it's boundaries <i>edge1</i> and <i>edge2</i>.
<br/><b>smstep(1, 2, x)</b>:<br/><img src="_equ#0#4#0#1#smstep(1,2,x)"/>
}}

{{ smstep2(edge1, edge2, x)
Smoothly fades between 0 and 1 for the value <i>x</i> between it's boundaries <i>edge1</i> and <i>egde2</i>. This version has slightly different boundary derivatives as the <a href="#smstep">smstep</a> function.
<br/><b>smstep2(1, 2, x)</b>:<br/><img src="_equ#0#4#0#1#smstep2(1,2,x)"/>
}}

{{ smquant(x, q)
Works like <a href="#quant">quant</a> but smoothly fades between each quantized value.
<br/><b>smquant(x, 1)</b>:<br/><img src="_equ#0#4#0#4#smquant(x,1)"/>
}}

{{ smquant2(x, q)
Sames as <a href="#smquant">smquant</a> but with slightly other derivatives of the smoothing function.
<br/><b>smquant2(x, 1)</b>:<br/><img src="_equ#0#4#0#4#smquant2(x,1)"/>
}}

{{ beta(x)
Calculates a circle's surface for input <i>x</i> in the range [-1,1]. For example <i>x</i> could be the x coordinate and the result would be the y coordinate of the circumference of a circle of radius 1 centered at the origin.
<br/>The underlying equation is: <b>beta(x) = sqrt(1-x*x)</b> which would be undefined for x outside the range of [-1,1]. In this case the function returns zero.
<br/><b>beta(x)</b>:<br/><img src="_equ#-1#1#0#1#beta(x)#200#100"/>
}}

{{ beta(x, y)
Calculates a sphere's surface for input range [-1,1]. For example <i>x</i> and <i>y</i> could be the x and y coordinates and the result would be the z coordinate of the periphery of a sphere of radius 1 centered at the origin.
<br/>The underlying equation is: <b>beta(x,y) = sqrt(1-x*x-y*y)</b>
}}

{{ beta(x, y, z)
Calculates a 4-dimensional sphere's surface for input range [-1,1].
<br/>The underlying equation is: <b>beta(x,y,z) = sqrt(1-x*x-y*y-z*z)</b>
}}

{{ beta(x, y, z, w)
Calculates a 5-dimensional sphere's surface for input range [-1,1].
<br/>The underlying equation is: <b>beta(x,y,z,w) = sqrt(1-x*x-y*y-z*z-w*w)</b>
}}

{{ mag(x, y)
Returns the magnitude or length of the 2d-vector (<i>x</i>, <i>y</i>)
}

{{ mag(x, y, z)
Returns the magnitude or length of the 3d-vector (<i>x</i>, <i>y</i>, <i>z</i>)
}}

{{ mag(x, y, z, w)
Returns the magnitude or length of the 4d-vector (<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>)
}}

{{ dist(x1, y1, x2, y2)
Returns the distance between the two 2d-coordinates (<i>x1</i>, <i>y1</i>) and (<i>x2</i>, <i>y2</i>)
}}

{{ rotate(x, y, d)
Rotates the 2d-coordinate (<i>x</i>, <i>y</i>) around the origin by the angle <i>d</i> in degree and returns the first component of the rotated vector. A common rotation would be:
<br/><b>x' = rotate(x, y, degree)
<br/>y' = rotate(y, x, -degree)</b>
}}

{{ rotater(x, y, r)
Rotates the 2d-coordinate (<i>x</i>, <i>y</i>) around the origin by the angle <i>r</i> in radians and returns the first component of the rotated vector. A common rotation would be:
<br/><b>x' = rotater(x, y, degree / 180 * PI)
<br/>y' = rotater(y, x, -degree / 180 * PI)</b>
}}

{{ ramp(x)
A ramp oscillator, output range [0,1].
<br/><b>ramp(x)</b>:<br/><img src="_equ#-1#1#-1#1#ramp(x)"/>
}}

{{ saw(x)
A sawtooth oscillator, output range [-1,1].
<br/><b>saw(x)</b>:<br/><img src="_equ#-1#1#-1#1#saw(x)"/>
}}

{{ square(x)
A square-wave oscillator, output range [-1,1].
<br/><b>square(x)</b>:<br/><img src="_equ#-1#1#-1#1#square(x)"/>
}}

{{ square(x, pw)
A square-wave oscillator with pulse-width control <i>b</i>, output range [-1,1]. <i>pw</i> is in the range of [0.000001,0.999999].
<br/><b>square(x, 0.1)</b>:<br/><img src="_equ#-1#1#-1#1#square(x,0.1)"/>
<br/><b>square(x, 0.9)</b>:<br/><img src="_equ#-1#1#-1#1#square(x,0.9)"/>
}}

{{ tri(x)
A triangle-wave oscillator, output range [-1,1].
<br/><b>tri(x)</b>:<br/><img src="_equ#-1#1#-1#1#tri(x)"/>
}}

{{ tri(x, pw)
A triangle-wave oscillator with pulse-width control <i>b</i>, output range [-1,1]. <br/><i>pw</i> is in the range of [0.000001,0.999999].
<br/><b>tri(x, 0.1)</b>:<br/><img src="_equ#-1#1#-1#1#tri(x,0.1)"/>
<br/><b>tri(x, 0.9)</b>:<br/><img src="_equ#-1#1#-1#1#tri(x,0.9)"/>
}}

{{ rnd()
Returns a pseudo-random number in the range [0,1].
<br/>A new random number is generated on each call of the function. Generally it's highly experimental to use functions like this anywhere. If you need "predictable" randomness, use <a href="#noise">noise</a> instead.
<br/><b>rnd(x)</b>:<br/><img src="_equ#0#1#0#1#rnd()"/>
}}

{{ noise(x)
Returns a 1-dimensional smoothed pseudo-random number in the range [-1,1].
<br/><b>noise(x)</b>:<br/><img src="_equ#-4#4#-1#1#noise(x)"/>
}}

{{ noise(x, y)
Returns a 2-dimensional smoothed pseudo-random number in the range [-1,1].
<br/><b>noise(x, 0)</b>:<br/><img src="_equ#-4#4#-1#1#noise(x,0)"/>
}}

{{ noise(x, y, z)
Returns a 3-dimensional smoothed pseudo-random number in the range [-1,1].
<br/><b>noise(x, 0, 0)</b>:<br/><img src="_equ#-4#4#-1#1#noise(x,0,0)"/>
}}

{{ noiseoct(x, o)
Returns a 1-dimensional smoothed pseudo-random number in the range of about [-2,2]. The noise function is octaved, meaning there are <i>o</i> number of noises mixed together, each with double the frequency and half the amplitude. The number of octaves is limited to 10.
<br/><b>noise(x, 4)</b>:<br/><img src="_equ#-4#4#-1#1#noiseoct(x,4)"/>
}}

{{ noiseoct(x, y, o)
Returns a 2-dimensional smoothed pseudo-random number in the range of about [-2,2]. The noise function is octaved, meaning there are <i>o</i> number of noises mixed together, each with double the frequency and half the amplitude. The number of octaves is limited to 10.
<br/><b>noise(x, 0, 4)</b>:<br/><img src="_equ#-4#4#-1#1#noiseoct(x,0,4)"/>
}}

{{ noiseoct(x, y, z, o)
Returns a 3-dimensional smoothed pseudo-random number in the range of about [-2,2]. The noise function is octaved, meaning there are <i>o</i> number of noises mixed together, each with double the frequency and half the amplitude. The number of octaves is limited to 10.
<br/><b>noise(x, 0, 0, 4)</b>:<br/><img src="_equ#-4#4#-1#1#noiseoct(x,0,0,4)"/>
}}

{{ fac(x)
Returns the factorial of <i>x</i>. E.g. the factorial of 7 is calculated as: 1 * 2 * 3 * 4 * 5 * 6 * 7
}}

{{ gamma(x)
Calculates the gamma function of <i>x</i>. The gamma function is like the <a href="#fac">factorial</a> function but for non-integers. If <i>x</i> is integer, the result is the factorial of <i>x</i>-1. The valid input range is about [0.0001,171].
<br/><b>gamma(x)<b>:<br/><img src="_equ#0#5#0#25#gamma(x)"/>
}}


{{ fib(x)
Returns the <i>x</i>th fibonacci number. Fibonacci numbers are defined as:
<br/>fib(n) = fib(n-2) + fib(n-1 where fib(0) and fib(1) are initially 1
}}

{{ zeta(x)
Approximates the Riemann zeta function of <i>a</i> with 70 iterations.
}}

{{ zeta(x, t)
Approximates the Riemann zeta function of <i>x</i> until the change per iteration is equal or lower than <i>t</i>, or the number of iterations reaches 200000
}}

{{ harmo(x, y)
Returns the harmonic quotient of <i>x</i>/<i>y</i> or <i>y</i>/<i>x</i>. If neither of the terms results in an integer, the result is 0.
}}

{{ harmo(x, y, z)
Returns the harmonic quotient of the term <i>x</i>/<i>y</i>/<i>z</i> or of the 5 other permutations in the order of this term. If neither of the terms results in an integer, the result is 0.
}}

{{ prime(n)
Returns 1 if integer <i>n</i> is a prime number and 0 otherwise. The first about million numbers have a look-up table for efficient execution.
<br/><b>prime(x)</b>:<br/><img src="_equ#0#100#0#1#prime(x)"/>
}}

{{ prime_s(n)
Smooth version of <a href="#prime">prime</a>.
<br/><b>prime_s(x)</b>:<br/><img src="_equ#0#100#0#1#prime_s(x)"/>
}}

{{ quer(n)
Returns the cross sum of the integer number <i>n</i>. The cross sum is the sum of all digits of a number, in this case in the base 10 system. When the sum is calculated, the cross sum is taken again until only one digit remains.
<br/><b>quer(x)</b>:<br/><img src="_equ#0#100#0#20#quer(x)"/>
}}

{{ uspiral(x, y)
Returns the ulam spiral number for the integer coordinate (<i>x</i>, <i>y</i>).
The ulam spiral lives in the integer grid, starts at 1 and extends counter-clockwise in square spirals.
<br/><img src="ulam_spiral.png"/>
}}

{{ uspiral(x, y, w)
Returns the <a href="#ulam2">ulam</a> spiral number for the integer coordinate (<i>x</i>, <i>y</i>) with additional width parameter <i>w</i>. Instead of a quadratic expansion, the spiral extents rectangular with the longest edges on the x axis.
}}

{{ tspiral(x, y)
Returns the triangle spiral number for the integer coordinate (<i>x</i>, <i>y</i>). The triangle spiral lives in the integer grid, starts at 1 and extends counter-clockwise in triangles around itself.
<br/>Note that not all positions are defined for the triangle spiral. These undefined positions return zero.
}}

{{ ndiv(n)
Returns the number of divisors of the integer <i>n</i>. The first about million numbers have a look-up table for efficient execution.
<br/><b>ndiv(x)</b>:<br/><img src="_equ#0#100#0#20#ndiv(x)"/>
}}

{{ divisor(n, i)
Returns the <i>i</i>th divisor of the integer <i>n</i>. The first about 260,000 numbers have a look-up table for efficient execution.
}}
<br/><b>divisor(x,3)</b>:<br/><img src="_equ#0#100#0#20#divisor(x,3)"/>

{{ sumdiv(n)
Returns the sum of all the divisors of the integer <i>n</i>. The first about 260,000 numbers have a look-up table for efficient execution.
<br/><b>sumdiv(x)</b>:<br/><img src="_equ#0#100#0#100#sumdiv(x)"/>
}}

{{ proddiv(n)
Returns the product of all the divisors of the integer <i>n</i>. The first about 260,000 numbers have a look-up table for efficient execution.
<br/><b>proddiv(x)</b>:<br/><img src="_equ#0#100#0#10000#proddiv(x)"/>
}}

{{ nextdiv(n, d)
Returns the next divisor of the integer <i>n</i>, starting at <i>d</i>. It does not matter if <i>d</i> is actually a divisor of <i>n</i>. There is no look-up table and this function might be relatively slow.
}}

{{ gcd(a, b)
Returns the greatest common divisor of the integers <i>a</i> and <i>b</i>. There is no look-up table and this function might be relatively slow.
}}

{{ cong(a, b, m)
Returns 1 if the integers <i>a</i> and <i>b</i> are congruent in the modulo space of <i>m</i> and 0 otherwise. The calculation is: <b>cong(a,b,m) = ((b-a) modulo m) equals 0</b>
}}

{{ digits(n)
Returns the number of digits of the integer <i>n</i> in the base 10 system.
}}

{{ ndiv_s(n)
This is the smoothed version of <a href="#ndiv1">ndiv</a>
<br/><b>ndiv_s(x)</b>:<br/><img src="_equ#0#100#0#20#ndiv_s(x)"/>
}}

{{ divisor_s(n, i)
This is the smoothed version of <a href="#divisor2">divisor</a>
<br/><b>divisor_s(x,3)</b>:<br/><img src="_equ#0#100#0#20#divisor_s(x,3)"/>
}}

{{ sumdiv_s(n)
This is the smoothed version of <a href="#sumdiv1">sumdiv</a>
<br/><b>sumdiv_s(x)</b>:<br/><img src="_equ#0#100#0#100#sumdiv_s(x)"/>
}}

{{ proddiv_s(n)
This is the smoothed version of <a href="#proddiv1">proddiv</a>
<br/><b>proddiv_s(x)</b>:<br/><img src="_equ#0#100#0#10000#proddiv_s(x)"/>
}}

{{ nextdiv_s(n, d)
This is the smoothed version of <a href="#nextdiv2">nextdiv</a>
}}

{{ gcd_s(a, b)
This is the smoothed version of <a href="#gcd2">gcd</a>
}}

{{ cong_s(a, b, m)
This is the smoothed version of <a href="#cong3">cong</a>
}}

{{ digits_s(n)
This is the smoothed version of <a href="#digits1">digits</a>
}}

{{ mandel(x, y)
Returns the approximation of the Mandelbrot function. The input variables are the real (<i>x</i>) and imaginary (<i>y</i>) part in the equation: <b>z(n+1) = z(n) ^ 2 + c</b>; where <b>z</b> and <b>c</b> are complex numbers. <b>z</b> is initially zero and <b>c</b> is initialized to the input variables. The result of the function is the real part of <b>z</b> after a maximum of 1000 iterations, or until z exceeds the limit of sqrt(-2).
<br/><b>mandel(x,1)</b>:<br/><img src="_equ#-2#2#0#6#mandel(x,1)"/>
}}

{{ mandel(x, y, i)
Sames as <a href="#mandel2">mandel(x, y)</a> but with the number of maximum iterations given in <i>i</i>.
<br/><b>mandel(x,1,10)</b>:<br/><img src="_equ#-2#2#0#6#mandel(x,1,10)"/>
}}

{{ mandeli(x, y)
Returns the number of iterations after which <b>z</b> in the mandelbrot function exceeds the limit of sqrt(-2). The maximum iteration is fixed to 1000.
<br/><b>mandeli(x,1)</b>:<br/><img src="_equ#-2#2#0#20#mandeli(x,1)"/>
}}

{{ mandeli(x, y, i)
Same as <a href="#mandeli2">mandeli(x, y)</a> but with the number of maximum iterations given in <i>i</i>.
<br/><b>mandeli(x,1,10)</b>:<br/><img src="_equ#-2#2#0#20#mandeli(x,1,10)"/>
}}

{{ julia(x, y, im, re)
Returns the value of the julia fractal (superset of the <a href="#mandel2">mandelbrot</a>) for the coordinate (<i>x</i>, <i>y</i>), with start values for the complex number <b>c</b> of (<i>im</i>, <i>re</i>). The number of iterations is fixed to 1000.
<br/><b>julia(x, 0, -0.3, 0.63)</b>:<br/><img src="_equ#-2#2#0#5#julia(x,0,-0.3,0.63)"/>
}}

{{ juliai(x, y, im, re)
Returns the number of iteration (maximally 1000) after which the value of <b>z</b> in the <a href="#julia">julia</a> function exceeds the boundary of sqrt(-2).
<br/><b>juliai(x, 0, -0.3, 0.63)</b>:<br/><img src="_equ#-2#2#0#500#juliai(x,0,-0.3,0.63)"/>
}}
