
/* generated by cppy on 2016-12-14 01:15:06.039519 */

#include <python3.4/Python.h>
#include <python3.4/structmember.h>

#include "mo3.h"

#ifndef CPPY_ERROR
#   include <iostream>
#   define CPPY_ERROR(arg__) { std::cerr << arg__ << std::endl; }
#endif

#ifndef CPPY_UNUSED
#   define CPPY_UNUSED(arg__) (void)arg__
#endif

/* compatibility checks */
#include <type_traits>
static_assert(std::is_same<freefunc,
    void(*)(void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<binaryfunc,
    PyObject*(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<visitproc,
    int(*)(PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getter,
    PyObject*(*)(PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getiterfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<hashfunc,
    Py_hash_t(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizessizeobjargproc,
    int(*)(PyObject*, Py_ssize_t, Py_ssize_t, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizessizeargfunc,
    PyObject*(*)(PyObject*, Py_ssize_t, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<richcmpfunc,
    PyObject*(*)(PyObject*, PyObject*, int)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setattrfunc,
    int(*)(PyObject*, char*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<lenfunc,
    Py_ssize_t(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizeobjargproc,
    int(*)(PyObject*, Py_ssize_t, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<descrgetfunc,
    PyObject*(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<unaryfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<descrsetfunc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizeargfunc,
    PyObject*(*)(PyObject*, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<objobjproc,
    int(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setattrofunc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getattrofunc,
    PyObject*(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ternaryfunc,
    PyObject*(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<reprfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<inquiry,
    int(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<allocfunc,
    PyObject*(*)(struct _typeobject*, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setter,
    int(*)(PyObject*, PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<initproc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<printfunc,
    int(*)(PyObject*, FILE*, int)>::value, "cppy/python api mismatch");
static_assert(std::is_same<traverseproc,
    int(*)(PyObject*, visitproc, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<objobjargproc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<newfunc,
    PyObject*(*)(struct _typeobject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getattrfunc,
    PyObject*(*)(PyObject*, char*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<iternextfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<destructor,
    void(*)(PyObject*)>::value, "cppy/python api mismatch");

namespace MO {
namespace PYTHON34 {

/* forwards */
extern "C" {

} // extern "C"

} // namespace PYTHON34
} // namespace MO

/* declarations from configuration */


/* user declarations */


/* start the python c-api tango */
namespace MO {
namespace PYTHON34 {


/* #################### class Timeline ##################### */

extern "C" {

    static const char* Timeline_struct_doc_string = "";
    /* -- 'Timeline' struct member impl -- */
    void Timeline_struct::cppy_new()
    {

    }
    void Timeline_struct::cppy_free()
    {

    }
    void Timeline_struct::cppy_copy(Timeline_struct* copy)
    {
        CPPY_UNUSED(copy);

    }

    /* ---------- Timeline structs ----------- */

    static PyMethodDef Timeline_method_struct[] =
    {

        { NULL, NULL, 0, NULL }
    };
    /* https://docs.python.org/3/c-api/typeobj.html */
    static PyTypeObject Timeline_type_struct =
    {
        PyVarObject_HEAD_INIT(NULL, 0)
        /* tp_name */           static_cast<const char*>        ("mo3.Timeline"),
        /* tp_basicsize */      static_cast<Py_ssize_t>         (sizeof(Timeline_struct)),
        /* tp_itemsize */       static_cast<Py_ssize_t>         (NULL),
        /* tp_dealloc */        static_cast<destructor>         (destroy_Timeline),
        /* tp_print */          static_cast<printfunc>          (NULL),
        /* tp_getattr */        static_cast<getattrfunc>        (NULL),
        /* tp_setattr */        static_cast<setattrfunc>        (NULL),
        /* tp_reserved */       static_cast<void*>              (NULL),
        /* tp_repr */           static_cast<reprfunc>           (NULL),
        /* tp_as_number */      static_cast<PyNumberMethods*>   (NULL),
        /* tp_as_sequence */    static_cast<PySequenceMethods*> (NULL),
        /* tp_as_mapping */     static_cast<PyMappingMethods*>  (NULL),
        /* tp_hash */           static_cast<hashfunc>           (NULL),
        /* tp_call */           static_cast<ternaryfunc>        (NULL),
        /* tp_str */            static_cast<reprfunc>           (NULL),
        /* tp_getattro */       static_cast<getattrofunc>       (PyObject_GenericGetAttr),
        /* tp_setattro */       static_cast<setattrofunc>       (PyObject_GenericSetAttr),
        /* tp_as_buffer */      static_cast<PyBufferProcs*>     (NULL),
        /* tp_flags */          static_cast<unsigned long>      (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE),
        /* tp_doc */            static_cast<const char*>        (Timeline_struct_doc_string),
        /* tp_traverse */       static_cast<traverseproc>       (NULL),
        /* tp_clear */          static_cast<inquiry>            (NULL),
        /* tp_richcompare */    static_cast<richcmpfunc>        (NULL),
        /* tp_weaklistoffset */ static_cast<Py_ssize_t>         (NULL),
        /* tp_iter */           static_cast<getiterfunc>        (NULL),
        /* tp_iternext */       static_cast<iternextfunc>       (NULL),
        /* tp_methods */        static_cast<struct PyMethodDef*>(Timeline_method_struct),
        /* tp_members */        static_cast<struct PyMemberDef*>(NULL),
        /* tp_getset */         static_cast<struct PyGetSetDef*>(NULL),
        /* tp_base */           static_cast<struct _typeobject*>(NULL),
        /* tp_dict */           static_cast<PyObject*>          (NULL),
        /* tp_descr_get */      static_cast<descrgetfunc>       (NULL),
        /* tp_descr_set */      static_cast<descrsetfunc>       (NULL),
        /* tp_dictoffset */     static_cast<Py_ssize_t>         (NULL),
        /* tp_init */           static_cast<initproc>           (NULL),
        /* tp_alloc */          static_cast<allocfunc>          (NULL),
        /* tp_new */            reinterpret_cast<newfunc>       (create_Timeline),
        /* tp_free */           static_cast<freefunc>           (NULL),
        /* tp_is_gc */          static_cast<inquiry>            (NULL),
        /* tp_bases */          static_cast<PyObject*>          (NULL),
        /* tp_mro */            static_cast<PyObject*>          (NULL),
        /* tp_cache */          static_cast<PyObject*>          (NULL),
        /* tp_subclasses */     static_cast<PyObject*>          (NULL),
        /* tp_weaklist */       static_cast<PyObject*>          (NULL),
        /* tp_del */            static_cast<destructor>         (NULL),
        /* tp_version_tag */    static_cast<unsigned int>       (NULL),
        /* tp_finalize */       static_cast<destructor>         (NULL)
    }; /* Timeline_type_struct */

    /* ---------- Timeline ctor/dtor ----------- */

    /** Creates new instance of Timeline class.
        @note Original function signature requires to return PyObject*,
        but here we return the actual Timeline struct for convenience. */
    Timeline_struct* create_Timeline()
    {
        auto o = PyObject_New(Timeline_struct, &Timeline_type_struct);
        o->cppy_new();
        return o;
    }

    /** Deletes a Timeline instance */
    void destroy_Timeline(PyObject* self)
    {
        reinterpret_cast<Timeline_struct*>(self)->cppy_free();
        self->ob_type->tp_free(self);
    }

    /** Makes a copy of the Timeline instance @p self,
        using user-supplied Timeline_struct::cppy_copy() */
    Timeline_struct* copy_Timeline(Timeline_struct* self)
    {
        Timeline_struct* copy = create_Timeline();
        self->cppy_copy(copy);
        return copy;
    }

    /** Wrapper for type checking after declaration of Timeline_type_struct */
    bool is_Timeline(PyObject* arg)
    {
        return PyObject_TypeCheck(arg, &Timeline_type_struct);
    }
} // extern "C"

bool initialize_class_Timeline(void* vmodule)
{
    PyObject* module = reinterpret_cast<PyObject*>(vmodule);

    if (0 != PyType_Ready(&Timeline_type_struct))
    {
        CPPY_ERROR("Failed to readify class Timeline for Python 3.4 module");
        return false;
    }

    PyObject* object = reinterpret_cast<PyObject*>(&Timeline_type_struct);
    Py_INCREF(object);
    if (0 != PyModule_AddObject(module, "Timeline", object))
    {
        Py_DECREF(object);
        CPPY_ERROR("Failed to add class Timeline to Python 3.4 module");
        return false;
    }
    return true;
}
extern "C" {
    /* module definition for 'mo3' */
    static const char* cppy_module_mo3_doc = "";
    static PyModuleDef cppy_module_mo3 =
    {
        PyModuleDef_HEAD_INIT,
        /* m_name */     static_cast<const char*> ("mo3"),
        /* m_doc */      static_cast<const char*> (cppy_module_mo3_doc),
        /* m_size */     static_cast<Py_ssize_t>  (-1),
        /* m_methods */  static_cast<PyMethodDef*>(nullptr),
        /* m_reload */   static_cast<inquiry>     (NULL),
        /* m_traverse */ static_cast<traverseproc>(NULL),
        /* m_clear */    static_cast<inquiry>     (NULL),
        /* m_free */     static_cast<freefunc>    (NULL)
    }; /* cppy_module_mo3 */
} // extern "C"

namespace {
    PyMODINIT_FUNC create_module_mo3_func()
    {
        auto module = PyModule_Create(&cppy_module_mo3);
        if (!module)
            return nullptr;

        // add the classes
        initialize_class_Timeline(module);

        return module;
    }
} // namespace

bool initialize_module_mo3()
{
    PyImport_AppendInittab("mo3", create_module_mo3_func);
    return true;
}
} // namespace PYTHON34
} // namespace MO
/* footer from configuration */
