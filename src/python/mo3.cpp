
/* generated by cppy on 2016-12-15 11:07:55.033137 */

#include <python3.4/Python.h>
#include <python3.4/structmember.h>

#include "mo3.h"

#ifndef CPPY_ERROR
#   include <iostream>
#   define CPPY_ERROR(arg__) { std::cerr << arg__ << std::endl; }
#endif

#ifndef CPPY_UNUSED
#   define CPPY_UNUSED(arg__) (void)arg__
#endif

/* compatibility checks */
#include <type_traits>
static_assert(std::is_same<newfunc,
    PyObject*(*)(struct _typeobject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<richcmpfunc,
    PyObject*(*)(PyObject*, PyObject*, int)>::value, "cppy/python api mismatch");
static_assert(std::is_same<objobjargproc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<destructor,
    void(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getattrfunc,
    PyObject*(*)(PyObject*, char*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ternaryfunc,
    PyObject*(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<unaryfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<iternextfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<visitproc,
    int(*)(PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<printfunc,
    int(*)(PyObject*, FILE*, int)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setattrfunc,
    int(*)(PyObject*, char*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<reprfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<traverseproc,
    int(*)(PyObject*, visitproc, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<inquiry,
    int(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setter,
    int(*)(PyObject*, PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<descrgetfunc,
    PyObject*(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<allocfunc,
    PyObject*(*)(struct _typeobject*, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<descrsetfunc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizessizeobjargproc,
    int(*)(PyObject*, Py_ssize_t, Py_ssize_t, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getiterfunc,
    PyObject*(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getter,
    PyObject*(*)(PyObject*, void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<lenfunc,
    Py_ssize_t(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizeobjargproc,
    int(*)(PyObject*, Py_ssize_t, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<initproc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<getattrofunc,
    PyObject*(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<hashfunc,
    Py_hash_t(*)(PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<freefunc,
    void(*)(void*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizeargfunc,
    PyObject*(*)(PyObject*, Py_ssize_t)>::value, "cppy/python api mismatch");
static_assert(std::is_same<objobjproc,
    int(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<setattrofunc,
    int(*)(PyObject*, PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<binaryfunc,
    PyObject*(*)(PyObject*, PyObject*)>::value, "cppy/python api mismatch");
static_assert(std::is_same<ssizessizeargfunc,
    PyObject*(*)(PyObject*, Py_ssize_t, Py_ssize_t)>::value, "cppy/python api mismatch");

/* declarations from configuration */


/* user declarations */
#include "math/TimelineNd.h"
#include "py_mo_helper.h"

using namespace PyUtils;

#define MO__ASSERT_TL(struct__)     if (struct__->tl == nullptr)     {         setPythonError(PyExc_ReferenceError, "attached timeline is NULL");         return NULL;     }     if (struct__->tl->numDimensions() == 0)     {         setPythonError(PyExc_ReferenceError,                 "timeline dimensionality is NULL");         return NULL;     }

namespace MO {
namespace PYTHON34 {

/* forwards */
extern "C" {
    //PyObject* toPython(MO::MATH::TimelineNd*);
    bool py_get_time_and_vec(
        PyObject* args_, double* time, MATH::TimelineNd::ValueType* vec);
    bool py_get_time_and_vec_and_pointtype(
            PyObject* args_, double* time, MATH::TimelineNd::ValueType* vec,
            int* ptype);
} // extern "C"

} // namespace PYTHON34
} // namespace MO

/* start the python c-api tango */
namespace MO {
namespace PYTHON34 {


/* #################### class Timeline ##################### */

extern "C" {

    static const char* Timeline_struct_doc_string = "_CPP_:\n    MATH::TimelineNd* tl;";
    /* -- 'Timeline' struct member impl -- */
    void Timeline_struct::cppy_new()
    {
        tl = nullptr;
    }
    void Timeline_struct::cppy_free()
    {
        if (tl)
            tl->releaseRef("py free");
    }
    void Timeline_struct::cppy_copy(Timeline_struct* copy)
    {
        CPPY_UNUSED(copy);
        if (tl)
            copy->tl = new MATH::TimelineNd(*tl);
    }

    /* ---------- Timeline methods ----------- */

    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:104 */
    static int cppy_classmethod_Timeline___init__(PyObject* arg0, PyObject* arg1, PyObject* arg2)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); CPPY_UNUSED(arg2); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        long l;
        arg1 = removeArgumentTuple(arg1);
        if (!expectFromPython(arg1, &l))
            return -1;
        self->tl = new MATH::TimelineNd(l);
        return 0;
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:115 */
    static PyObject* cppy_classmethod_Timeline___str__(PyObject* arg0)
    {
        CPPY_UNUSED(arg0); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        return toPython(QString("Timeline(dim %1, points %2)")
              .arg(self->tl->numDimensions())
              .arg(self->tl->size()) );
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:302 */
    static const char* cppy_classmethod_Timeline_add_doc = "add(float, vec) -> self\nadd(float, vec, int) -> self\nAdds a value/vector at the given time.\nThe vector size must fit the dimension of the timeline data.\nThe third argument can be on of the Timeline point types,\nCONSTANT, LINEAR, SMOOTH, SYMMETRIC, SYMMETRIC_USER, HERMITE,\nSPLINE4, SPLINE6";
    static PyObject* cppy_classmethod_Timeline_add(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        /*
        double time;
        MATH::TimelineNd::ValueType
                val(self->tl->numDimensions(), MATH::TimelineNd::ValueType::NoInit);
        int ptype = MATH::TimelinePoint::DEFAULT;
        if (!py_get_time_and_vec_and_pointtype(arg1, &time, &val, &ptype))
        {
            //MO_DEBUG("TODO Python Timeline: PTYPE not retrieved");
            PyErr_Clear();
            if (!py_get_time_and_vec(arg1, &time, &val))
                return NULL;
        }
        self->tl->add(time, val, (MATH::TimelinePoint::Type)ptype);
        */
        Py_RETURN_SELF;
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:183 */
    static const char* cppy_classmethod_Timeline_as_set_doc = "as_set() -> set\n\"\n        Returns a set containing the times of all timeline points";
    static PyObject* cppy_classmethod_Timeline_as_set(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        auto set = PySet_New(NULL);
        if (!set)
        {
            setPythonError(PyExc_MemoryError, "Could not create set object");
            return NULL;
        }
        for (auto& i : self->tl->getData())
        {
            auto d = toPython(i.second.t);
            if (!d)
            {
                Py_DECREF(set);
                return NULL;
            }
            if (PySet_Add(set, d) < 0)
            {
                Py_DECREF(set);
                return NULL;
            }
        }
        return set;
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:213 */
    static const char* cppy_classmethod_Timeline_copy_doc = "copy() -> Timeline\nReturns a new instance with the same data";
    static PyObject* cppy_classmethod_Timeline_copy(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        return (PyObject*)copy_Timeline(self);
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:239 */
    static const char* cppy_classmethod_Timeline_derivative_doc = "derivative(f, f) -> f | list\nReturns the derivative at the given time.\nThe optional second argument is the time range to observe, initialized to 0.01\nIf dimension is 1, returns float.\nIf dimension is >1, returns list of float";
    static PyObject* cppy_classmethod_Timeline_derivative(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        double time, range = 0.01;
        if (!PyArg_ParseTuple(arg1, "d|d", &time, &range))
            return NULL;
        range = .5001 * std::max(range, MATH::TimelineNd::timeQuantum());
        if (self->tl->numDimensions() == 1)
            return toPython(self->tl->getDerivative(time, range)[0]);
        return toPython(self->tl->getDerivative(time, range));
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:258 */
    static const char* cppy_classmethod_Timeline_get_timeline_doc = "get_timeline(i) -> Timeline | None\nReturns the i'th dimension as one-dimensional timeline.";
    static PyObject* cppy_classmethod_Timeline_get_timeline(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        long idx = PyLong_AsLong(arg1);
        if (idx < 0 || (size_t)idx >= self->tl->numDimensions())
        {
            setPythonError(PyExc_IndexError, SStream() << "Dimension out of range "
                        << idx << "/" << self->tl->numDimensions());
            return NULL;
        }
        auto tl1 = self->tl->getTimelineNd(idx, 1);
        auto ret = reinterpret_cast<PyObject*>(toPython(tl1));
        tl1->releaseRef("py create finish");
        return ret;
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:278 */
    static const char* cppy_classmethod_Timeline_set_dimensions_doc = "set_dimensions(long) -> None\nSets the number of dimensions which must be at least one.\nEach point in the timeline is affected. If the dimensionality grows,\nnew data is initialized to zero.";
    static PyObject* cppy_classmethod_Timeline_set_dimensions(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        long num;
        if (!PyArg_ParseTuple(arg1, "l", &num))
            return NULL;
        if (num<1 || num>4)
        {
            setPythonError(PyExc_TypeError,
                SStream() << "number of dimensions out of range 1<=" << num << "<=4");
            return NULL;
        }
        self->tl->setDimensions(num);
        if (num<1 || num>4)
        self->tl->setDimensions(num);
        Py_RETURN_NONE;
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:222 */
    static const char* cppy_classmethod_Timeline_value_doc = "value(f) -> f | list\nReturns the value at the given time\nIf dimension is 1, returns float.\nIf dimension is >1, returns list of float";
    static PyObject* cppy_classmethod_Timeline_value(PyObject* arg0, PyObject* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        double time;
        if (!fromPython(arg1, &time))
            return NULL;
        if (self->tl->numDimensions() == 1)
            return toPython(self->tl->get(time)[0]);
        return toPython(self->tl->get(time));
    }

    /* ---------- Timeline properties ----------- */

    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:124 */
    static const char* Timeline_dimensions_doc = "dimensions() -> int\nReturns the number of dimensions, e.g. the number of components per vector";
    static PyObject* Timeline_dimensions_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        return toPython(self->tl->numDimensions());
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:158 */
    static const char* Timeline_end_doc = "end() -> float\nThe time of the last cue in seconds";
    static PyObject* Timeline_end_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        return toPython(self->tl->empty()
                        ? 0.0 : self->tl->getData().rbegin()->second.t);
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:170 */
    static const char* Timeline_length_doc = "length() -> float\nThe time between the first and last cue in seconds";
    static PyObject* Timeline_length_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        return toPython(self->tl->empty() ? 0.0
                    : self->tl->getData().rbegin()->second.t
                      - self->tl->getData().begin()->second.t);
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:135 */
    static const char* Timeline_size_doc = "size() -> int\nReturns the number of points";
    static PyObject* Timeline_size_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        return toPython(self->tl->size());
    }
    /* /home/defgsus/prog/qt_project/mo/matrixoptimizer/src/python/mo3/impl/timeline.py:146 */
    static const char* Timeline_start_doc = "start() -> float\nThe time of the first cue in seconds";
    static PyObject* Timeline_start_getter(PyObject* arg0, void* arg1)
    {
        CPPY_UNUSED(arg0); CPPY_UNUSED(arg1); 
        Timeline_struct* self = reinterpret_cast<Timeline_struct*>(arg0);
        MO__ASSERT_TL(self);
        return toPython(self->tl->empty()
                        ? 0.0 : self->tl->getData().begin()->second.t);
    }

    /* ---------- Timeline structs ----------- */

    static PyMethodDef Timeline_method_struct[] =
    {
        { "add", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_add), METH_VARARGS, cppy_classmethod_Timeline_add_doc },
        { "as_set", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_as_set), METH_NOARGS, cppy_classmethod_Timeline_as_set_doc },
        { "copy", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_copy), METH_NOARGS, cppy_classmethod_Timeline_copy_doc },
        { "derivative", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_derivative), METH_VARARGS, cppy_classmethod_Timeline_derivative_doc },
        { "get_timeline", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_get_timeline), METH_O, cppy_classmethod_Timeline_get_timeline_doc },
        { "set_dimensions", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_set_dimensions), METH_O, cppy_classmethod_Timeline_set_dimensions_doc },
        { "value", reinterpret_cast<PyCFunction>(cppy_classmethod_Timeline_value), METH_O, cppy_classmethod_Timeline_value_doc },

        { NULL, NULL, 0, NULL }
    };
    static PyGetSetDef Timeline_getset_struct[] =
    {
        { (char*)"dimensions", (getter)Timeline_dimensions_getter, (setter)NULL, (char*)Timeline_dimensions_doc, (void*)NULL },
        { (char*)"end", (getter)Timeline_end_getter, (setter)NULL, (char*)Timeline_end_doc, (void*)NULL },
        { (char*)"length", (getter)Timeline_length_getter, (setter)NULL, (char*)Timeline_length_doc, (void*)NULL },
        { (char*)"size", (getter)Timeline_size_getter, (setter)NULL, (char*)Timeline_size_doc, (void*)NULL },
        { (char*)"start", (getter)Timeline_start_getter, (setter)NULL, (char*)Timeline_start_doc, (void*)NULL },

        { NULL, NULL, NULL, NULL, NULL }
    };
    /* https://docs.python.org/3/c-api/typeobj.html */
    static PyTypeObject Timeline_type_struct =
    {
        PyVarObject_HEAD_INIT(NULL, 0)
        /* tp_name */           static_cast<const char*>        ("mo3.Timeline"),
        /* tp_basicsize */      static_cast<Py_ssize_t>         (sizeof(Timeline_struct)),
        /* tp_itemsize */       static_cast<Py_ssize_t>         (NULL),
        /* tp_dealloc */        static_cast<destructor>         (destroy_Timeline),
        /* tp_print */          static_cast<printfunc>          (NULL),
        /* tp_getattr */        static_cast<getattrfunc>        (NULL),
        /* tp_setattr */        static_cast<setattrfunc>        (NULL),
        /* tp_reserved */       static_cast<void*>              (NULL),
        /* tp_repr */           static_cast<reprfunc>           (NULL),
        /* tp_as_number */      static_cast<PyNumberMethods*>   (NULL),
        /* tp_as_sequence */    static_cast<PySequenceMethods*> (NULL),
        /* tp_as_mapping */     static_cast<PyMappingMethods*>  (NULL),
        /* tp_hash */           static_cast<hashfunc>           (NULL),
        /* tp_call */           static_cast<ternaryfunc>        (NULL),
        /* tp_str */            static_cast<reprfunc>           (cppy_classmethod_Timeline___str__),
        /* tp_getattro */       static_cast<getattrofunc>       (PyObject_GenericGetAttr),
        /* tp_setattro */       static_cast<setattrofunc>       (PyObject_GenericSetAttr),
        /* tp_as_buffer */      static_cast<PyBufferProcs*>     (NULL),
        /* tp_flags */          static_cast<unsigned long>      (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE),
        /* tp_doc */            static_cast<const char*>        (Timeline_struct_doc_string),
        /* tp_traverse */       static_cast<traverseproc>       (NULL),
        /* tp_clear */          static_cast<inquiry>            (NULL),
        /* tp_richcompare */    static_cast<richcmpfunc>        (NULL),
        /* tp_weaklistoffset */ static_cast<Py_ssize_t>         (NULL),
        /* tp_iter */           static_cast<getiterfunc>        (NULL),
        /* tp_iternext */       static_cast<iternextfunc>       (NULL),
        /* tp_methods */        static_cast<struct PyMethodDef*>(Timeline_method_struct),
        /* tp_members */        static_cast<struct PyMemberDef*>(NULL),
        /* tp_getset */         static_cast<struct PyGetSetDef*>(Timeline_getset_struct),
        /* tp_base */           static_cast<struct _typeobject*>(NULL),
        /* tp_dict */           static_cast<PyObject*>          (NULL),
        /* tp_descr_get */      static_cast<descrgetfunc>       (NULL),
        /* tp_descr_set */      static_cast<descrsetfunc>       (NULL),
        /* tp_dictoffset */     static_cast<Py_ssize_t>         (NULL),
        /* tp_init */           static_cast<initproc>           (cppy_classmethod_Timeline___init__),
        /* tp_alloc */          static_cast<allocfunc>          (NULL),
        /* tp_new */            reinterpret_cast<newfunc>       (create_Timeline),
        /* tp_free */           static_cast<freefunc>           (NULL),
        /* tp_is_gc */          static_cast<inquiry>            (NULL),
        /* tp_bases */          static_cast<PyObject*>          (NULL),
        /* tp_mro */            static_cast<PyObject*>          (NULL),
        /* tp_cache */          static_cast<PyObject*>          (NULL),
        /* tp_subclasses */     static_cast<PyObject*>          (NULL),
        /* tp_weaklist */       static_cast<PyObject*>          (NULL),
        /* tp_del */            static_cast<destructor>         (NULL),
        /* tp_version_tag */    static_cast<unsigned int>       (NULL),
        /* tp_finalize */       static_cast<destructor>         (NULL)
    }; /* Timeline_type_struct */

    /* ---------- Timeline ctor/dtor ----------- */

    /** Creates new instance of Timeline class.
        @note Original function signature requires to return PyObject*,
        but here we return the actual Timeline struct for convenience. */
    Timeline_struct* create_Timeline()
    {
        auto o = PyObject_New(Timeline_struct, &Timeline_type_struct);
        o->cppy_new();
        return o;
    }

    /** Deletes a Timeline instance */
    void destroy_Timeline(PyObject* self)
    {
        reinterpret_cast<Timeline_struct*>(self)->cppy_free();
        self->ob_type->tp_free(self);
    }

    /** Makes a copy of the Timeline instance @p self,
        using user-supplied Timeline_struct::cppy_copy() */
    Timeline_struct* copy_Timeline(Timeline_struct* self)
    {
        Timeline_struct* copy = create_Timeline();
        self->cppy_copy(copy);
        return copy;
    }

    /** Wrapper for type checking after declaration of Timeline_type_struct */
    bool is_Timeline(PyObject* arg)
    {
        return PyObject_TypeCheck(arg, &Timeline_type_struct);
    }
} // extern "C"

bool initialize_class_Timeline(void* vmodule)
{
    PyObject* module = reinterpret_cast<PyObject*>(vmodule);

    if (0 != PyType_Ready(&Timeline_type_struct))
    {
        CPPY_ERROR("Failed to readify class Timeline for Python 3.4 module");
        return false;
    }

    PyObject* object = reinterpret_cast<PyObject*>(&Timeline_type_struct);
    Py_INCREF(object);
    if (0 != PyModule_AddObject(module, "Timeline", object))
    {
        Py_DECREF(object);
        CPPY_ERROR("Failed to add class Timeline to Python 3.4 module");
        return false;
    }
    return true;
}
extern "C" {
    /* module definition for 'mo3' */
    static const char* cppy_module_mo3_doc = "_CPP_(HEADER):\n    namespace MO { namespace MATH { class TimelineNd; template <typename T> class ArithmeticArray; } }";
    static PyModuleDef cppy_module_mo3 =
    {
        PyModuleDef_HEAD_INIT,
        /* m_name */     static_cast<const char*> ("mo3"),
        /* m_doc */      static_cast<const char*> (cppy_module_mo3_doc),
        /* m_size */     static_cast<Py_ssize_t>  (-1),
        /* m_methods */  static_cast<PyMethodDef*>(nullptr),
        /* m_reload */   static_cast<inquiry>     (NULL),
        /* m_traverse */ static_cast<traverseproc>(NULL),
        /* m_clear */    static_cast<inquiry>     (NULL),
        /* m_free */     static_cast<freefunc>    (NULL)
    }; /* cppy_module_mo3 */
    /* ##### c-api wrapper implementation ##### */
    /*
    PyObject* toPython(MO::MATH::TimelineNd* tl)
    {
        ret = create_Timeline();
        ret->tl = tl;
        if (tl)
            tl->addRef("py create");
        return (PyObject*)ret;
    }

    bool py_get_time_and_vec(
        PyObject* args_, double* time, MATH::TimelineNd::ValueType* vec)
    {
        if (vec->numDimensions() == 1)
        {
            if (PyArg_ParseTuple(args_, "dd", time, &(*vec)[0]))
                return true;
        }
        else if (vec->numDimensions() == 2)
        {
            if (PyArg_ParseTuple(args_, "ddd", time, &(*vec)[0], &(*vec)[1]))
                return true;
        }
        else if (vec->numDimensions() == 3)
        {
            if (PyArg_ParseTuple(args_, "dddd", time, &(*vec)[0], &(*vec)[1], &(*vec)[2]))
                return true;
        }
        else if (vec->numDimensions() == 4)
        {
            if (PyArg_ParseTuple(args_, "ddddd", time, &(*vec)[0], &(*vec)[1], &(*vec)[2], &(*vec)[3]))
                return true;
        }
        PyErr_Clear();
        PyObject * second;
        if (!PyArg_ParseTuple(args_, "dO", time, &second))
            return false;
        if (get_vector(second, vec->numDimensions(), &(*vec)[0]))
            return true;
        return false;
    }

    bool py_get_time_and_vec_and_pointtype(
            PyObject* args_, double* time, MATH::TimelineNd::ValueType* vec,
            int* ptype)
    {
        if (vec->numDimensions() == 1)
        {
            if (PyArg_ParseTuple(args_, "ddi", time, &(*vec)[0], ptype))
                return true;
        }
        else if (vec->numDimensions() == 2)
        {
            if (PyArg_ParseTuple(args_, "dddi", time, &(*vec)[0], &(*vec)[1], ptype))
                return true;
        }
        else if (vec->numDimensions() == 3)
        {
            if (PyArg_ParseTuple(args_, "ddddi",
                                 time, &(*vec)[0], &(*vec)[1], &(*vec)[2], ptype))
                return true;
        }
        else if (vec->numDimensions() == 4)
        {
            if (PyArg_ParseTuple(args_, "dddddi",
                    time, &(*vec)[0], &(*vec)[1], &(*vec)[2], &(*vec)[3], ptype))
                return true;
        }
        PyErr_Clear();
        PyObject * second;
        if (!PyArg_ParseTuple(args_, "dOi", time, &second, ptype))
            return false;
        if (get_vector(second, vec->numDimensions(), &(*vec)[0]))
            return true;
        return false;
    }*/
} // extern "C"

namespace {
    PyMODINIT_FUNC create_module_mo3_func()
    {
        auto module = PyModule_Create(&cppy_module_mo3);
        if (!module)
            return nullptr;

        // add the classes
        initialize_class_Timeline(module);

        return module;
    }
} // namespace

bool initialize_module_mo3()
{
    PyImport_AppendInittab("mo3", create_module_mo3_func);
    return true;
}
} // namespace PYTHON34
} // namespace MO
/* footer from configuration */
